# 线程池

<img src="https://gitee.com/xu-binyao/typora-images/raw/master/img/202304271858493.png" alt="image-20230427185849611" style="zoom:67%;" />

## 1. 线程池的创建方式

不推荐通过Executors类的静态方法创建如下线程池

> FixedThreadPool (固定个数)
> ScheduledThreadPool (执行周期性任务)
> WorkStealingPool (根据当前电脑CPU处理器数量生成相应线程数)
> CachedThreadPool (带缓存功能)
> SingleThreadPool (单个线程)

```java
public static void main(String[] args) {
        try (ExecutorService executorService = Executors.newSingleThreadExecutor()) {
            executorService.execute(() -> {
                System.out.println("I'm running in " + Thread.currentThread().getName()); 					// I'm running in pool-1-thread-1
            });
        }
    }
```

![img](https://img-blog.csdnimg.cn/8051e2e0ed1041eca8446a08b7182645.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YC-5ZCs6ZOD55qE5aOw,size_20,color_FFFFFF,t_70,g_se,x_16)

推荐通过ThreadPoolExecutor创建线程池

![image-20230428135924754](https://gitee.com/xu-binyao/typora-images/raw/master/img/202304281359093.png)

```java
//全参构造方法
public ThreadPoolExecutor(int corePoolSize,  //核心线程数
                          int maximumPoolSize,  //最大线程数
                          //非核心线程数 = 最大线程数 — 核心线程数
                          //非核心线程阻塞一段时间后没拿到任务 会销毁
                          long keepAliveTime, //非核心线程的存活时间（也是阻塞队列的超时时间）
                          TimeUnit unit,//救急线程的存活时间的单位
                          BlockingQueue<Runnable> workQueue, //阻塞队列/工作队列
                          ThreadFactory threadFactory, //线程工厂(可以给线程添加名字方便查找)
                          RejectedExecutionHandler handler) //拒绝策略 策略模式的体现
```

 实例：

```java
    // 给线程定义有业务含义的名称
    ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat("thread-pool-%s").build();
    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
            5,  // 线程池核心线程数
            10,  // 线程池最大线程数，达到最大值后线程池不会再增加线程
            1000,  // 线程池中超过corePoolSize数目的空闲线程最大存活时间
            TimeUnit.MILLISECONDS,  // 时间单位，毫秒
            new LinkedBlockingQueue<>(50),  // 工作线程等待队列，通过Executors创建的内部这里的LinkedBlockingQueue为无参构造，最大容量为Integer.MAX_VALUE
            threadFactory,  // 自定义线程工厂
            new ThreadPoolExecutor.AbortPolicy());  // 线程池满时的拒绝策略
```

## 2. 线程池的执行流程

<img src="https://img-blog.csdnimg.cn/5db854418f5b486aafb392ba07d532ac.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YC-5ZCs6ZOD55qE5aOw,size_17,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:67%;" />

```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();、
    //获得ctl
    int c = ctl.get();
    //工作线程是否小于核心线程数 ? 
    
    if (workerCountOf(c) < corePoolSize) {
        //假设工作线程小于核心线程 
        //那么直接创建工作线程执行任务
        if (addWorker(command, true))
            //添加成功直接返回
            return;
        //走到这里 说明已有其他线程添加了工作线程 重新获得ctl
        c = ctl.get();
    }
    //工作队列是否已经排满了任务 ?
    if (isRunning(c) && workQueue.offer(command)) {
        //能进入这个if 说明 线程池处于running状态
        //并且 阻塞队列里面能添加任务（即阻塞队列的容量没满）
        //再次获得ctl  做一个检查
        int recheck = ctl.get();
        //如果线程池不是running状态 那么删除该任务
        if (! isRunning(recheck) && remove(command))
            //执行拒绝策略
            reject(command);
        //这种情况说明线程池中的工作线程数量为0  
        //那么需要添加一个非核心线程去处理任务
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    //工作线程是否已经达到了最大线程数
    else if (!addWorker(command, false))
        //假如核心线程已经满了 并且线程数已经达到了线程池最大线程数限制 并且任务队列里面的容量已经满了
        reject(command);
}
```

## 3. 线程池的四种拒绝策略（策略模式的体现）

### CallerRunsPolicy（在当前线程执行）

策略一：直接交给调用线程执行

![image-20230428134522101](https://gitee.com/xu-binyao/typora-images/raw/master/img/202304281345539.png)

### AbortPolicy（抛异常）

策略二：直接抛异常

![image-20230428134838882](https://gitee.com/xu-binyao/typora-images/raw/master/img/202304281348141.png)

### DiscardPolicy（丢弃线程）

策略三：什么都不做

![image-20230428134943762](https://gitee.com/xu-binyao/typora-images/raw/master/img/202304281349734.png)

### DiscardOldestPolicy（丢弃一个未被处理的最久的线程，然后重试）

策略四：弹出最先加入线程池的任务，然后执行当前的任务

```java
public static class DiscardOldestPolicy implements RejectedExecutionHandler {
    /**
         * Creates a {@code DiscardOldestPolicy} for the given executor.
         */
    public DiscardOldestPolicy() { }

    /**
         * Obtains and ignores the next task that the executor
         * would otherwise execute, if one is immediately available,
         * and then retries execution of task r, unless the executor
         * is shut down, in which case task r is instead discarded.
         *
         * @param r the runnable task requested to be executed
         * @param e the executor attempting to execute this task
         */
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        if (!e.isShutdown()) {
            //弹出队首元素（也就是说弹出最先加入队列的任务）
            e.getQueue().poll();
            //重试
            e.execute(r);
        }
    }
}
```

当没有显示指明拒绝策略时，默认使用AbortPolicy 

## 4. 线程池状态

### 4.1. 线程池核心属性 ctl

```java
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
// Integer.SIZE - 3 = 29
// 1，高 三位表示 线程池的状态
// 2，低二十九位表示 线程池的工作线程数量
private static final int COUNT_BITS = Integer.SIZE - 3;
//00000000 00000000 00000000 00000001
//1 << 29
//00100000 00000000 00000000 00000000
//(1 << COUNT_BITS) - 1
//00011111 11111111 11111111 11111111
private static final int CAPACITY   = (1 << COUNT_BITS) - 1;

// runState is stored in the high-order bits
//线程池的5种状态
//-1的二进制
//11111111 11111111 11111111 11111111
//1110 0000 0000 0000 0000 0000 0000 0000
private static final int RUNNING    = -1 << COUNT_BITS;
//0000 0000 0000 0000 0000 0000 0000 0000
private static final int SHUTDOWN   =  0 << COUNT_BITS;
//0010 0000 0000 0000 0000 0000 0000 0000
private static final int STOP       =  1 << COUNT_BITS;
//0100 0000 0000 0000 0000 0000 0000 0000
private static final int TIDYING    =  2 << COUNT_BITS;
//0110 0000 0000 0000 0000 0000 0000 0000
private static final int TERMINATED =  3 << COUNT_BITS;


//根据 ctl 获得当前线程池的状态 
//CAPACITY
//00011111 11111111 11111111 11111111
//~CAPACITY
//11100000 00000000 00000000 00000000
//所以 c(ctl) & ~CAPACITY 得到的前三位是线程池的状态，后面全部为0
private static int runStateOf(int c)     { return c & ~CAPACITY; }

//屏蔽掉了前三位，根据 ctl 获得工作线程的数量
private static int workerCountOf(int c)  { return c & CAPACITY; }
```

### 4.2. 线程池状态切换

![image-20230428143906530](https://gitee.com/xu-binyao/typora-images/raw/master/img/202304281439986.png)

![img](https://img-blog.csdnimg.cn/43d80f004b174b77968aa81baa6097a3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YC-5ZCs6ZOD55qE5aOw,size_20,color_FFFFFF,t_70,g_se,x_16)

## 5，execute方法

通过execute方法 可以查看线程池的整体执行流程

```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    //获取ctl，ctl是包含了了线程池的状态和线程数量的一个变量
    int c = ctl.get();
    //工作线程数量是否 < 核心线程数量？
    if (workerCountOf(c) < corePoolSize) {
        //添加核心线程执行command任务  
        //参数2为true 表示的是创建核心线程
        //参数2为false 表示的是添加非核心线程
        if (addWorker(command, true))
            //添加核心线程成功 返回true 
            return;
        //说明添加失败了 重新获得ctl 
        c = ctl.get();
    }
    
    if (isRunning(c) && workQueue.offer(command)) {
        ////当前线程池是 Running && 添加任务到工作队列成功 
        //再次获取ctl
        int recheck = ctl.get();
        //判断线程池是否是Running() 如果不是Running状态 需要将任务从工作队列中移除
        if (! isRunning(recheck) && remove(command))
            //执行拒绝策略
            reject(command);
        //判断工作线程是否为 0 
        else if (workerCountOf(recheck) == 0)
            //工作线程数为 0 但是工作线程中有任务在排队
            //添加一个空任务 非核心线程， 为了处理在工作队列中排队的任务
            addWorker(null, false);
    }
    //添加任务失败 
    //添加非核心线程执行
    //参数2为true 表示的是创建核心线程
    //参数2为false 表示的是添加非核心线程
    else if (!addWorker(command, false))
        //添加非核心线程失败 执行拒绝策略
        reject(command);
}
```



## 6，addWorker方法

![image-20230428183301433](upload/image-20230428183301433.png)

```java
//添加工作线程 or 核心线程
private boolean addWorker(Runnable firstTask, boolean core) {
    //外层for循环的标识
    //对线程池的状态的判断，以及对工作线程的数量的判断
    retry:
    for (;;) {
        //获得ctl
        int c = ctl.get();
        //获取当前线程池的状态
        int rs = runStateOf(c);

        //一：什么时候会出现添加工作线程失败的情况？
            //首先线程池的状态满足>=SHUTDOWN,即不是RUNNING
            //1，线程池的状态是 STOP 因为STOP状态不需要处理任何任务  那么不需要创建工作线程
            // OR
            //2，线程池的状态是 SHUTDOWN 并且 firstTask不为空    因为SHUTDOWN状态下 线程池只会处理工作队列里面的剩余的任务  那么不需要创建工作线程
            // OR
            //3，线程池的状态是 SHUTDOWN 并且 firstTask == null 并且 工作队列里面没有剩余的任务 那么不需要创建工作线程
        
        //二：什么时候会出现添加工作线程成功的情况？
        	// rs为running，可以创建线程
        	// 此外rs == SHUTDOWN && 当前任务为空 && 任务队列不为空，也可以继续创建线程
         if (rs >= SHUTDOWN && !(rs == SHUTDOWN && firstTask == null && !workQueue.isEmpty()))
                return false;
        
        //对线程数量的判断
        for (;;) {
            //获取工作线程数量
            int wc = workerCountOf(c);
            
            //工作线程数量已经超过了最大容量 || 如果创建的是核心线程 是否已经超过了核心线程的最大数量？ 如果是救急线程 是否超过了最大线程的数量？
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            //CAS 增加工作线程数 成功直接跳出外层for循环
            if (compareAndIncrementWorkerCount(c))
                break retry;
            //CAS失败
            //重新获得ctl的值
            c = ctl.get();  // Re-read ctl
            //获得线程池状态
            if (runStateOf(c) != rs)
                //如果线程池状态发生了改变 
                //继续执行外层循环 即重新判断线程池的状态
                
                //如果线程池状态没有发生改变
                //那么继续执行内存for循环 即重新改变线程池的线程数量
                continue retry;
            // else CAS failed due to workerCount change; retry inner loop
        }
    }
	// 执行到这里说明上面成功增加了一个工作线程数
    
    // 下面的任务是添加工作线程 并且启动工作线程
    
    //工作线程是否启动？作为最后的返回值了
    boolean workerStarted = false;
    //工作线程是否添加？
    boolean workerAdded = false;
    //工作线程
    Worker w = null;
    try {
        //构建工作线程
        w = new Worker(firstTask);
        //work中的thread线程
        final Thread t = w.thread;
        
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;
            //上锁 为什么要加锁？
            //避免 避免此时其他线程把线程池状态改为非false
            mainLock.lock();
            try {
                // Recheck while holding lock.
                // Back out on ThreadFactory failure or if
                // shut down before lock acquired.
                //重新获得线程池的状态
                int rs = runStateOf(ctl.get());
                //线程池状态是RUNNING 添加工作线程
                if (rs < SHUTDOWN ||
  // 线程池状态是 SHUTDOWN 并且当前任务是null，成功添加了一个工作线程说明上面是工作队列中有线程等待，加的是工作队列中的线程，也符合
                    (rs == SHUTDOWN && firstTask == null)) {
                    //work的线程是否已经start了？ 如果已经start 不合法 健壮性判断
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    //开始添加工作线程
                    
                    //将worker添加到workers工作组
                    workers.add(w);
                    //获取现在工作线程个数
                    int s = workers.size();
                    if (s > largestPoolSize)
                        //largestPoolSize 记录最大工作线程数量
                        largestPoolSize = s;
                    //工作线程的添加
                    workerAdded = true;
                }
            } finally {
                //释放锁
                mainLock.unlock();
            }
            if (workerAdded) {
// 开启线程，如果这行出异常了，就执行不到workerStarted=true了，就会进入下面addWorkerFailed(w)的补救
                t.start();
                //更改线程是否已经开启状态
                workerStarted = true;
            }
        }
    } finally {
        //启动工作线程失败
        if (! workerStarted)
            //工作线程池启动失败之后的补救工作
            addWorkerFailed(w);
    }
    return workerStarted;
}

//启动工作线程失败后 做的补救操作
private void addWorkerFailed(Worker w) {
    //上锁
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        if (w != null)
            workers.remove(w);
        //减少工作线程的数量
        decrementWorkerCount();
        //尝试将线程池的状态变为
        tryTerminate();
    } finally {
        //释放锁
        mainLock.unlock();
    }
}
```





## 7，Worker对象

```java
private final class Worker
    extends AbstractQueuedSynchronizer //线程池中断
    implements Runnable //存储需要执行的任务
{

    private static final long serialVersionUID = 6138294804551838833L;
 
    //工作线程
    final Thread thread;
    //需要执行的任务
    Runnable firstTask;
    volatile long completedTasks;

    Worker(Runnable firstTask) {
        //AQS里面的属性设置为 -1 表示当前线程不允许被中断 因为当前线程是刚刚开始初始化的
        setState(-1);
        this.firstTask = firstTask;
        this.thread = getThreadFactory().newThread(this);
    }

    //调用线程t.start()方法 执行当前的run方法
    public void run() {
        runWorker(this);
    }
		// Lock methods
        //
        // The value 0 represents the unlocked state.
        // The value 1 represents the locked state.
    protected boolean isHeldExclusively() {  // 判断线程是否是独有的
        return getState() != 0;  // 1说明线程处于锁住状态，是独有的
    }

    protected boolean tryAcquire(int unused) {
        if (compareAndSetState(0, 1)) {
            setExclusiveOwnerThread(Thread.currentThread())// 被当前线程独占
            return true;
        }
        return false;
    }

    //将state设置为 0，在runWorker中 ，为了表示当前线程允许被中断
    protected boolean tryRelease(int unused) {
        setExclusiveOwnerThread(null); // 没有线程独占
        setState(0);
        return true;
    }

    public void lock()        { acquire(1); }
    public boolean tryLock()  { return tryAcquire(1); }
    public void unlock()      { release(1); }
    public boolean isLocked() { return isHeldExclusively(); }

    void interruptIfStarted() {
        Thread t;
        if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {
            try {
                t.interrupt();
            } catch (SecurityException ignore) {
            }
        }
    }
}
```



## 8，runWorker方法

![image-20230429162325331](https://gitee.com/xu-binyao/typora-images/raw/master/img/202304291623781.png)

这两个方法的区别就是clearInterrupted参数值不一样

![image-20230429162555243](https://gitee.com/xu-binyao/typora-images/raw/master/img/202304291625765.png)

![image-20230429163138505](upload/image-20230429163138505.png)

执行任务  

```java
final void runWorker(Worker w) {
    //当前线程
    Thread wt = Thread.currentThread();
    //work里面的任务
    Runnable task = w.firstTask;
    //任务置空
    w.firstTask = null;
    //当前线程允许被中断
    w.unlock(); // allow interrupts
    boolean completedAbruptly = true;
    try {
        //获取任务的两个方式
        //1，就是执行 execute , submit 时 ， 传入的任务直接处理
        //2，从阻塞队列里面拿出任务来处理
        while (task != null || (task = getTask()) != null) {
            //加锁  在shutdown状态下 当前状态是不允许被中断的 代表当前线程正在执行任务
            //并且worker内部实现的aqs 并不是可重入锁
            w.lock();
            // If pool is stopping, ensure thread is interrupted;
            // if not, ensure thread is not interrupted.  This
            // requires a recheck in second case to deal with
            // shutdownNow race while clearing interrupt
            // 如果线程池的状态变为了 stop状态 必须将当前线程中断
            // 判断1 当前线程池状态是否是stop状态及以上
            // 判断2 Thread.interrupted() 查询中断标记位 并归位 如果为false  说明不是并且有其他线程并发操作将线程池状态变化为了stop
            if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &&        runStateAtLeast(ctl.get(), STOP))) &&
                //查询当前线程中断标记是否为false，如果为false，就执行 wt.interrupt();
                !wt.isInterrupted())
                //将中断标记为设置为true
                //总之 就是在线程池STOP状态下 需要设置为true
                wt.interrupt();
            try {
                //钩子函数 前置增强
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    //执行任务
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    //钩子函数 后置增强
                    afterExecute(task, thrown);
                }
            } finally {
                //任务设置为null
                task = null;
                //任务数++
                w.completedTasks++;
                //解锁
                w.unlock();
            }
        }
        //任务正常执行完 这里是false
        completedAbruptly = false;
    } finally {
        processWorkerExit(w, completedAbruptly);
    }
}
```



## 9，getTask

从工作队列中获取到任务

```java
private Runnable getTask() {
    //工作线程是否需要通过poll方法去阻塞队列获得任务？
    boolean timedOut = false; // Did the last poll() time out?

    //死循环
    for (;;) {
        //===========================判断线程池的状态==================================
        //获得ctl
        int c = ctl.get();
        //获得线程池的状态
        int rs = runStateOf(c);

        // Check if queue empty only if necessary.
        //进入if  需要干掉当前工作线程
        //不是RUNNING
        // 1.如果线程池的状态已经是 STOP 需要移除当前工作线程
        // 2.如果线程池的状态为SHUTDOWN 并且工作队列里面没有任务了 
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            //扣除worker的数量 移除当前工作线程
            decrementWorkerCount();
            //返回null 交给 processWorkerExit移除当前工作线程
            return null;
        }
        
        //===========================获取线程的数量=================================
        //获得线程的数量
        int wc = workerCountOf(c);

        // Are workers subject to culling?
        // allowCoreThreadTimeOut -> 允许核心线程超时么？ 默认false
        // wc > corePoolSize; 工作线程是否已经大于核心线程数
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

        //工作线程是否大于了最大线程数？（基本不可能 
        //工作线程已经大于了核心线程数 && 当前线程已经过了阻塞时间 超时了
        //尝试干掉当前线程
        if ((wc > maximumPoolSize || (timed && timedOut))
            //如果工作队列为空 我就干掉我自己
            //如果工作线程数大于1 我就干掉我自己（交给剩余的线程处理即可）
            && (wc > 1 || workQueue.isEmpty())) {
            //cas移除当前线程 ， 只有一个线程会cas成功
            if (compareAndDecrementWorkerCount(c))
                //返回null 交给 processWorkerExit移除当前工作线程
                return null;
            continue;
        }

        try {
            //核心线程也允许超时 or 工作线程已经大于了核心线程数
            Runnable r = timed ?
                //阻塞一定时间从工作队列里面拿任务 超过时间拿不到就返回null（可以理解为非核心线程走这里）
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
            //一直阻塞（可以理解为核心线程走这里）
            workQueue.take();   
            // poll方法和take方法区别在于，poll方法未获取到直接返回null，而take方法未获取到会阻塞
            
            if (r != null)
                //拿到任务 直接返回执行
                return r;
            //当前线程获取任务超时了（达到了当前工作线程的最大生存时间）
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
```



## 10，processWorkerExit

runWorker方法的finally语句块里面有调用这个方法

```java
private void processWorkerExit(Worker w, boolean completedAbruptly) {
    
    //completedAbruptly 任务出了异常 就是true
    //任务没有出异常 就是 false
    //假如任务出现了异常 我们需要将出现异常的线程移除掉 然后添加新的线程
    if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted
        decrementWorkerCount();

    //加锁
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        // 记录当前线程池一共处理了多少任务
        completedTaskCount += w.completedTasks;
        //移除工作线程
        workers.remove(w);
    } finally {
        mainLock.unlock();
    }

    //尝试将线程池关闭（到过度状态） 
    tryTerminate();

    //获取ctl
    int c = ctl.get();
    //当前线程池状态 是 SHUTDOWN or RUNNING
    if (runStateLessThan(c, STOP)) {
        //如果是正常状态移除当前线程
        if (!completedAbruptly) {
            // 核心线程数的最小值 
            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
            
            if (min == 0 && ! workQueue.isEmpty())
                //工作队列里面的任务不为空 设置工作线程最小值为1
                min = 1;
            if (workerCountOf(c) >= min)
                //还有工作线程在线程池中 ，说明任务有线程可以处理 不需要创建新的线程
                return; // replacement not needed
        }
        //不正常的方式移除了当前线程 ，再添加一个工作线程（例如执行任务中出现了异常 重新补救一个新的线程）
        //工作队列不为空 并且没有工作线程 那么需要再添加一个工作线程
        addWorker(null, false);
    }
}
```



## 11，最终源码解析

```java
//拒绝策略接口
public interface MyRejectedExecutionHandler {

    //参数1  触发拒绝策略的任务
    //参数2  自定义的线程池
    void rejectedExecution(Runnable r, MyThreadPool executor);
}


public class MyThreadPool {

    //工作队列
    private final BlockingQueue<Runnable> workQueue;

    //线程创建工厂
    private volatile ThreadFactory threadFactory;

    //拒绝策略
    private MyRejectedExecutionHandler handler;

    //非核心线程存活时间
    private volatile long keepAliveTime;

    //该线程池中所有的线程的装载容器
    private final HashSet<Worker> workers = new HashSet<>();

    //核心线程数
    private volatile int corePoolSize;

    //最大线程数
    private volatile int maximumPoolSize;

    //并发过程中需要用到的锁
    private final ReentrantLock mainLock = new ReentrantLock();


    //线程池核心属性 ctl
    //低29位代表线程池里面的工作线程数量
    //高3位 代表线程池的状态
    //位运算略过
    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
    private static final int COUNT_BITS = Integer.SIZE - 3;
    private static final int CAPACITY = (1 << COUNT_BITS) - 1;

    // runState is stored in the high-order bits
    private static final int RUNNING = -1 << COUNT_BITS;
    private static final int SHUTDOWN = 0 << COUNT_BITS;
    private static final int STOP = 1 << COUNT_BITS;
    private static final int TIDYING = 2 << COUNT_BITS;
    private static final int TERMINATED = 3 << COUNT_BITS;


    //线程池中出现的最大线程数量
    private int largestPoolSize;


    /**
     * Counter for completed tasks. Updated only on termination of
     * worker threads. Accessed only under mainLock.
     */

    //线程池执行的任务数量汇总  他只有线程池中的线程即将会被移除的时候统计 并且他在锁内访问 线程安全
    private long completedTaskCount;


    /**
     * Wait condition to support awaitTermination
     */
    private final Condition termination = mainLock.newCondition();


    //打断工作线程的数量 一次性打断一个工作线程
    private static final boolean ONLY_ONE = true;


    //是否允许核心线程超时？ 默认不允许
    private volatile boolean allowCoreThreadTimeOut;


    //和权限相关的东西  不重要 不用关心~
    private static final RuntimePermission shutdownPerm =
        new RuntimePermission("modifyThread");


    //构造函数
    public MyThreadPool(int corePoolSize,
                        int maximumPoolSize,
                        long keepAliveTime,
                        TimeUnit unit,
                        BlockingQueue<Runnable> workQueue,
                        ThreadFactory threadFactory,
                        MyRejectedExecutionHandler handler) {
        //参数校验
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;

        //统一将存活时间的单位转化为Nanos
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }


    //线程池关闭的钩子函数 默认实现为null
    protected void terminated() {
    }

    //cas减少工作线程的数量
    private void decrementWorkerCount() {
        do {
        } while (!compareAndDecrementWorkerCount(ctl.get()));
    }


    //cas减少工作线程的数量
    private boolean compareAndDecrementWorkerCount(int expect) {
        return ctl.compareAndSet(expect, expect - 1);
    }

    // 获得线程池的状态
    private static int runStateOf(int c) {
        return c & ~CAPACITY;
    }

    //获得线程池工作线程的数量
    private static int workerCountOf(int c) {
        return c & CAPACITY;
    }


    //如果rs 或者 wc有一个为 0  那么就返回另外一个数字
    //该方法的目的就是为了改变线程池的状态 但是不能直接改
    //该方法改变线程池状态的同时会保留低29位的工作线程数量
    private static int ctlOf(int rs, int wc) {
        //wc
        //00000000 00000000  00000000  00000000
        return rs | wc;
    }


    //线程池的状态至少是s
    private static boolean runStateAtLeast(int c, int s) {
        return c >= s;
    }

    //cas操作增加工作线程数量
    private boolean compareAndIncrementWorkerCount(int expect) {
        return ctl.compareAndSet(expect, expect + 1);
    }

    //获得线程创建工厂
    public ThreadFactory getThreadFactory() {
        return threadFactory;
    }


    //判断线程池是否处于RUNNING状态
    private static boolean isRunning(int c) {
        return c < SHUTDOWN;
    }


    //方法的目的就是cas将线程池的状态切换
    private void advanceRunState(int targetState) {
        //死循环
        for (; ; ) {
            //获得ctl
            int c = ctl.get();
            //跳出死循环的条件
            //1，线程池的状态至少是SHUTDOWN（如果是SHUTDOWN的状态就不需要修改了 直接返回）
            //or
            //2，修改线程池的状态为SHUTDOWN成功
            if (runStateAtLeast(c, targetState) ||
                ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))
                break;
        }
    }

    //线程池的状态是否小于 状态s
    private static boolean runStateLessThan(int c, int s) {
        return c < s;
    }

    //钩子函数 在线程执行任务之后会触发 默认空实现
    protected void afterExecute(Runnable r, Throwable t) {
    }


    //钩子函数 在线程执行任务之前会触发 默认空实现
    protected void beforeExecute(Thread t, Runnable r) {
    }


    //从工作队列里面移除task任务
    public boolean remove(Runnable task) {
        boolean removed = workQueue.remove(task);
        //尝试关闭线程池 【因为如果工作队列里面没有任务】 || 【工作线程的数量为0】 都会触发线程池的关闭
        tryTerminate(); // In case SHUTDOWN and now empty
        return removed;
    }


    //执行拒绝策略 策略模式的体现
    final void reject(Runnable command) {
        handler.rejectedExecution(command, this);
    }

    //往线程池中提交任务
    public void execute(Runnable command) {
        //非空校验
        if (command == null)
            throw new NullPointerException();
        //获得ctl
        int c = ctl.get();
        //假如现在工作线程的数量小于核心线程的数量
        if (workerCountOf(c) < corePoolSize) {
            //添加工作线程 第二个参数为true表示添加的是核心线程
            if (addWorker(command, true))
                return;
            //走到这里说明添加核心工作线程失败 需要重新获得ctl
            c = ctl.get();
        }
        //【添加核心线程失败 || 当前工作线程已经超过了核心线程的数量】 并且 【线程池处于RUNNING状态 并且 成功地将任务塞进了工作队列】
        if (isRunning(c) && workQueue.offer(command)) {
            //线程池处于RUNNING状态 并且 成功地将任务添加到工作队列里面
            //重新获得ctl
            int recheck = ctl.get();

            //什么时候执行拒绝策略？
            //【线程池不是RUNNING状态】 并且 【成功将当前任务从工作队列里面移除】
            //为什么会这么做 ？ 因为如果此时线程池不是RUNNING状态了 说明其他线程并发修改了线程池的状态
            //处于SHUTDOWN  或者 STOP 状态的都不会执行最新的任务 所以执行拒绝策略
            if (!isRunning(recheck) && remove(command))
                //执行拒绝策略
                reject(command);
            else if (workerCountOf(recheck) == 0)
                //走到这里 【说明当前线程池的状态是 RUNNING 状态】  并且 【线程池里面没有工作线程 所以需要创建非核心线程去执行工作队列里面的任务】
                addWorker(null, false);

        }
        //走到这里 【说明核心线程已经满了】 并且 【工作队列里面已经塞满了】
        //这里会添加非核心线程来处理任务
        else if (!addWorker(command, false))
            //假如添加非核心线程失败 什么会导致失败？ 即工作线程数已经超过了线程池的最大线程数量[maximumPoolSize]
            //执行拒绝策略
            reject(command);
    }


    //添加工作线程的方法
    private boolean addWorker(Runnable firstTask, boolean core) {
        //外层循环的退出标识
        retry:
        //外层
        for (; ; ) {
            //获得ctl
            int c = ctl.get();
            //获得线程池的状态
            int rs = runStateOf(c);

            //什么时候会出现添加工作线程失败的情况？
            //首先线程池的状态不是RUNNING
            //1，线程池的状态是 STOP 因为STOP状态不需要处理任何任务  那么不需要创建工作线程
            // OR
            //2，线程池的状态是 SHUTDOWN 并且 firstTask不为空  因为SHUTDOWN状态下 线程池只会处理工作队列里面的剩余的任务  那么不需要创建工作线程
            // OR
            //3，线程池的状态是 SHUTDOWN 并且 firstTask == null 并且 工作队列里面没有剩余的任务 那么不需要创建工作线程
            if (rs >= SHUTDOWN && !(rs == SHUTDOWN && firstTask == null && !workQueue.isEmpty()))
                return false;

            //内层死循环
            for (; ; ) {
                //获得线程池工作线程的数量
                int wc = workerCountOf(c);
                //什么时候 不会添加工作线程？
                //1,如果工作线程的数量超过了最大线程数量 (一般不会)
                // OR
                //2,如果此次添加的是核心线程 并且当前工作线程已经超过了核心线程的最大数量
                // OR
                //3,如果此次添加的是非核心线程 但是当前工作线程已经超过了最大线程的限制数量
                if (wc >= CAPACITY || wc >= (core ? corePoolSize : maximumPoolSize))
                    return false;
                //通过cas使工作线程数目+1
                if (compareAndIncrementWorkerCount(c))
                    //如果cas成功 工作线程数量+1成功
                    //跳出外层循环
                    break retry;
                //cas失败 说明有其他线程同时让工作线程数量+1 那么再次尝试添加工作线程数量+1
                //重新获得ctl
                c = ctl.get();  // Re-read ctl

                //重新获得线程池的状态 如果 线程池的状态！= rs
                if (runStateOf(c) != rs)
                    //说明有其他线程导致线程池状态发生改变
                    //重新执行最外层循环 最外层会重新判断线程池的状态
                    continue retry;

                //走到这里说明线程池的状态没有发生改变 只是有并发操作添加线程池数量 那么只需要重新执行内层循环即可
            }
        }

        //标记线程是否开始
        boolean workerStarted = false;
        //标记线程是否已经添加
        boolean workerAdded = false;

        MyThreadPool.Worker w = null;
        try {
            //创建worker
            w = new MyThreadPool.Worker(firstTask);
            //获得worker的线程对象
            final Thread t = w.thread;
            if (t != null) {
                //加锁 这里为什么要加锁？
                //个人感觉是 workers这个不是线程安全的集合 同时addWorker()这个方法他不是高并发那种方法 所以加个锁不太影响性能
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    //获得当前线程池的状态
                    int rs = runStateOf(ctl.get());


                    //什么时候会真正添加工作线程？
                    // 1, 线程池是RUNNING状态
                    // or
                    // 2, 线程池处于SHUTDOWN状态 但是 firstTask 为 null （此时需要添加线程去处理工作队列里面的任务  因为 SHUTDOWN状态下还会处理工作队列里面没有处理的任务）
                    if (rs < SHUTDOWN || (rs == SHUTDOWN && firstTask == null)) {
                        //健壮性判断 才创建的worker对象 里面的thread线程一定是还未start的
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();

                        //将工作线程添加到workers里面
                        workers.add(w);
                        //获得workers的容量
                        int s = workers.size();
                        //更新一下工作线程中出现过的最大线程数
                        if (s > largestPoolSize)
                            largestPoolSize = s;
                        //线程添加标记设置为true
                        workerAdded = true;
                    }
                } finally {
                    //解锁
                    mainLock.unlock();
                }
                if (workerAdded) {
                    //worker添加成功
                    //开启线程 实际上是调用 worker对象里面的 runWorker方法
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            if (!workerStarted)
                //线程启动失败
                //
                addWorkerFailed(w);
        }
        return workerStarted;
    }


    //添加worker失败记录
    private void addWorkerFailed(MyThreadPool.Worker w) {
        final ReentrantLock mainLock = this.mainLock;
        //上锁 为什么要上锁？
        //个人觉得 是因为workers 是线程不安全的集合 所以对他操作的时候 加上锁保证线程安全
        mainLock.lock();
        try {
            if (w != null)
                //从worker集合中移除
                workers.remove(w);
            //工作线程数 - 1
            decrementWorkerCount();
            //尝试关闭线程池 【因为工作线程为0】  or 【工作队列里面没有任务数】 都会触发线程池关闭
            tryTerminate();
        } finally {
            mainLock.unlock();
        }
    }


    //打断工作线程
    //该方法只会打断一个工作线程
    private void interruptIdleWorkers(boolean onlyOne) {
        //onlyOne默认为true
        final ReentrantLock mainLock = this.mainLock;
        //上锁 为什么要上锁 因为workers不是线程安全的集合
        mainLock.lock();
        try {
            //遍历所有的worker
            for (MyThreadPool.Worker w : workers) {
                //获得worker里面的线程
                Thread t = w.thread;
                //如果线程没有被打断 并且 此时线程允许被中断(worker 自定实现了 aqs 他是不可重入锁)
                if (!t.isInterrupted() && w.tryLock()) {
                    try {
                        //将线程的中断标识改为true
                        t.interrupt();
                    } catch (SecurityException ignore) {
                    } finally {
                        //释放锁
                        w.unlock();
                    }
                }
                //onlyOne一直都是true(除非我们自己设置) 所以中断一个线程就ok
                if (onlyOne)
                    break;
            }
        } finally {
            //释放锁
            mainLock.unlock();
        }
    }


    //尝试将线程池关闭
    //当工作线程为 0 工作队列里面没有任务的时候 就会触发该方法
    final void tryTerminate() {
        //死循环
        for (; ; ) {
            //获取ctl
            int c = ctl.get();
            //什么时候会直接返回？
            //1，线程池正处于RUNNING状态
            //or
            //2，线程池已经是TIDYING 或者 TERMINATE 状态就直接返回 因为如果已经是TIDYING 或者 TERMINATE状态下 说明其他线程正在尝试关闭线程池或者已经关闭了线程池
            //or
            //3，线程池处于SHUTDOWN状态，并且工作队列里面还有剩余任务 那么肯定不能将线程池转化为Terminated状态
            if (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN && !workQueue.isEmpty()))
                return;
            //如果还存在工作线程 那么会遍历worker列表 选择一个线程进行中断
            if (workerCountOf(c) != 0) { // Eligible to terminate
                interruptIdleWorkers(ONLY_ONE);
                return;
            }


            final ReentrantLock mainLock = this.mainLock;
            //上锁
            mainLock.lock();
            try {
                //将线程池设置为TIDYING状态
                if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {
                    try {
                        //线程池关闭方法
                        //默认是空实现 需要交给子类去实现
                        terminated();
                    } finally {
                        //将线程池的状态设置为TERMINATED
                        ctl.set(ctlOf(TERMINATED, 0));
                        //TODO 唤醒等待线程池关闭的线程 ？ 意义在哪
                        termination.signalAll();
                    }
                    return;
                }
            } finally {
                //释放锁
                mainLock.unlock();
            }
            // else retry on failed CAS
        }
    }


    //工作线程对象
    private final class Worker extends AbstractQueuedSynchronizer implements Runnable {
        /**
         * This class will never be serialized, but we provide a
         * serialVersionUID to suppress a javac warning.
         */
        private static final long serialVersionUID = 6138294804551838833L;

        /**
         * Thread this worker is running in.  Null if factory fails.
         */
        //属于worker的线程
        final Thread thread;
        /**
         * Initial task to run.  Possibly null.
         */
        //属于worker的任务对象
        Runnable firstTask;
        /**
         * Per-thread task counter
         */
        //该worker已经完成的任务数
        volatile long completedTasks;


        //构造函数
        Worker(Runnable firstTask) {
            setState(-1); // inhibit interrupts until runWorker
            this.firstTask = firstTask;
            this.thread = getThreadFactory().newThread(this);
        }


        // Lock methods
        //
        // The value 0 represents the unlocked state.
        // The value 1 represents the locked state.

        //==========================worker实现的aqs  他的特点是独占锁 并且不可重入！
        protected boolean isHeldExclusively() {
            return getState() != 0;
        }

        protected boolean tryAcquire(int unused) {
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }

        protected boolean tryRelease(int unused) {
            setExclusiveOwnerThread(null);
            setState(0);
            return true;
        }

        public void lock() {
            acquire(1);
        }

        public boolean tryLock() {
            return tryAcquire(1);
        }

        public void unlock() {
            release(1);
        }

        public boolean isLocked() {
            return isHeldExclusively();
        }


        //==========================worker实现的aqs  他的特点是独占锁 并且不可重入！
        void interruptIfStarted() {
            Thread t;
            //任何线程都会被打断  不管是处于阻塞获取任务的线程 还是 正在执行任务的线程
            if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {
                try {
                    t.interrupt();
                } catch (SecurityException ignore) {
                }
            }
        }

        //worker里面的线程池启动会调用该方法
        @Override
        public void run() {
            this.runWorker(this);
        }


        //线程调用start方法后 会调用此方法
        final void runWorker(MyThreadPool.Worker w) {

            //获得当前线程
            Thread wt = Thread.currentThread();
            //获得worker里面的任务
            Runnable task = w.firstTask;
            //置空线程池里面的任务
            w.firstTask = null;

            //解锁 允许被打断 即在阻塞获取任务的过程中可以被打断
            w.unlock(); // allow interrupts
            //成功完成任务的标记 最初为true 如果任务执行的过程中出现了异常没有处理 那么他还是为true
            boolean completedAbruptly = true;
            try {
                //死循环
                //跳出死循环的一些情况
                //1，当前worker的task为null 并且 从阻塞队列里面获取不到任务了
                //or
                //2, 执行任务的过程中出现了异常 直接跳出while循环
                while (task != null || (task = getTask()) != null) {

                    //给线程上锁 防止该线程执行任务的过程中被中断
                    w.lock();
                    // If pool is stopping, ensure thread is interrupted;
                    // if not, ensure thread is not interrupted.  This
                    // requires a recheck in second case to deal with
                    // shutdownNow race while clearing interrupt

                    // 翻译上述英文注释
                    // 当线程池处于stop状态的时候 确保所有线程都是被中断的
                    // 如果线程池不是stop状态 确保所有线程不是中断的
                    // 这需要自旋来应对其他线程突然关闭线程池的情况

                    //Thread类的interrupted方法是返回当前线程的被打断状态,同时清除打断状态
                    //这个方法是直接调用isInterrupted方法,传了一个参数为true,意思是返回当前线程被打断状态的同时,清除打断状态,将打断状态置为false;


                    if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() && runStateAtLeast(ctl.get(), STOP))) && !wt.isInterrupted())
                        //什么时候会触发线程中断?
                        //1 , !wt.isInterrupted() 这个说明线程本身就要处于不是被中断的状态
                        // AND
                        //2 , 【线程池至少已经是STOP状态】 或者 【线程池已经是STOP状态（之前不是 ， 说明有其他线程把线程池设置为了STOP状态 那么 说明 此时线程已经是处于被打断的状态 调用 Thread.interrupted() 返回true 但是同时他会将打断标记
                        // 设置为 false  ）】

                        //将线程的中断标志设为TRUE
                        wt.interrupt();
                    try {
                        //钩子函数 默认是空实现 在任务执行前执行
                        beforeExecute(wt, task);
                        //任务执行的过程中可能出现的异常记录
                        Throwable thrown = null;
                        try {
                            //真正地执行任务
                            task.run();
                        } catch (RuntimeException x) {
                            thrown = x;
                            throw x;
                        } catch (Error x) {
                            thrown = x;
                            throw x;
                        } catch (Throwable x) {
                            thrown = x;
                            throw new Error(x);
                        } finally {
                            //钩子函数 会在任务执行后执行（出现异常与否 都会执行这个函数） 这里面会拿到出现的异常 和任务本身
                            //默认是空实现
                            //我们可以实现这个方法 对异常进行一些处理
                            //但是这样处理的话 粒度太大 所以我们建议在任务里面进行try{} catch{} 操作
                            afterExecute(task, thrown);
                        }
                    } finally {

                        //将任务设置为null
                        task = null;
                        //任务数++
                        w.completedTasks++;
                        //释放锁 允许被中断
                        w.unlock();
                    }
                }
                //假如任务中出现了异常 就不会走到这里
                completedAbruptly = false;
            } finally {
                //无论任务是否出现异常都会走这里
                //走到这里说明需要处理线程是否被移除
                processWorkerExit(w, completedAbruptly);
            }
        }
    }


    //需要处理线程是否被移除
    //从该方法里面我们得知 如果一个线程如果在执行任务的过程中出现了异常而未处理异常
    //该方法会针对这种情况将线程移除 然后再创建一个新的线程 作为补偿
    //所以我们要自己处理异常 减少线程的销毁与创建
    private void processWorkerExit(MyThreadPool.Worker w, boolean completedAbruptly) {
        //什么时候 completedAbruptly 是true ？ 就是任务执行的过程中出现了异常
        if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted
            //如果任务执行的过程中出现了异常 那么工作线程数量 - 1
            decrementWorkerCount();

        final ReentrantLock mainLock = this.mainLock;
        //上锁 为什么要上锁？
        //因为 workers 是线程不安全的集合 所以需要上锁保证线程安全
        //并且 线程池中任务总数的累加也需要保证线程安全
        mainLock.lock();
        try {
            //线程池完成的任务数量汇总
            completedTaskCount += w.completedTasks;
            //从worker里面
            workers.remove(w);
        } finally {
            //释放锁
            mainLock.unlock();
        }

        //尝试关闭线程池
        //为什么会尝试关闭线程池？
        //当工作线程的数量为 0  或者 工作队列里面的任务数都为0的时候会触发线程池关闭
        tryTerminate();

        //获得ctl
        int c = ctl.get();
        //如果线程池是 RUNNING 或者SHUTDOWN 状态
        if (runStateLessThan(c, STOP)) {
            //completedAbruptly 是true ？ 就是任务执行的过程中出现了异常
            if (!completedAbruptly) {
                //获得线程池应该存在的最小工作线程数量
                // allowCoreThreadTimeOut 默认 是 false  即不允许核心线程超时
                //假如允许核心线程超时 那么 min就是0 因为如果核心线程永不超时 那么 核心线程会永远存在
                //如果不允许核心线程超时 那么 min就是 corePoolSize
                int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
                //假如工作线程的最小值为0  并且工作队列里面还有任务需要执行
                if (min == 0 && !workQueue.isEmpty())
                    //设置工作线程最小数量
                    min = 1;
                if (workerCountOf(c) >= min)
                    //如果当前工作线程 >= min 那么不需要创建新的线程
                    return; // replacement not needed
            }

            //如果当前线程是因为执行任务的过程中出现了异常 那么会重新往线程池里面补充新的工作线程补偿
            addWorker(null, false);
        }
    }


    //获取任务
    private Runnable getTask() {
        //该线程获取任务是否超时
        //默认为false
        boolean timedOut = false; // Did the last poll() time out?

        //死循环
        for (; ; ) {
            //ctl
            int c = ctl.get();
            //获得线程池状态
            int rs = runStateOf(c);

            // Check if queue empty only if necessary.
            //什么时候会getTask失败？
            //1,线程池不是RUNNING状态
            //AND
            //2,线程池是STOP状态（STOP状态不会处理工作队列里面的任务）  ||  工作队列为空（自然获取不到任务）
            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
                //减少工作线程的数量
                decrementWorkerCount();
                //返回null
                return null;
            }

            //获得工作线程的数量
            int wc = workerCountOf(c);

            // Are workers subject to culling?

            //allowCoreThreadTimeOut 是否允许核心线程超时 一般为false
            //wc > corePoolSize; 工作线程的数量已经超过核心线程的数量
            boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

            //wc > maximumPoolSize 这个条件是工作线程已经大于最大线程限制（00011111 11111111 11111111 11111111）一般不会发生 直接无视
            //触发该线程获取任务失败的条件
            // 1 ， 该线程已经获取任务超时 timedOut就是true  并且 工作线程的数量已经超过核心线程的数量 timed就是true
            // AND
            // 2 ， 工作线程数量 >  1 || 或者工作队列为空
            // 所以这里可以看为非核心线程的淘汰（非核心线程在keepAliveTime 内没有获取到任务就会超时 然后下一轮for循环被淘汰）
            if ((wc > maximumPoolSize || (timed && timedOut)) && (wc > 1 || workQueue.isEmpty())) {
                //减少工作线程数量
                if (compareAndDecrementWorkerCount(c))
                    //cas成功减少 返回null
                    return null;
                //这里说明有其他线程并发减少工作线程数量 自旋重试
                continue;
            }

            try {
                // timed 为true 就说明了工作线程超过了核心线程的数量 超过核心线程的部分就是我们常说的非核心线程
                Runnable r = timed ?
                    //这里可以看为非核心线程 带超时时间等待获取任务 如果超时时间外没有获得任务 下轮for循环就会被剔除 因为 timedOut会变为true
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                //这里可以看位核心线程 获取任务 永不超时 如果没有任务就会永久阻塞 所以核心线程一般情况下 永久存在
                workQueue.take();
                if (r != null)
                    //任务不为空 返回
                    return r;
                //任务为空却走到了这里 说明是非核心线程获取任务超时
                //设置timedOut 为 true 下次for循环就会剔除该非核心线程
                timedOut = true;
            } catch (InterruptedException retry) {
                timedOut = false;
            }
        }
    }

    /**
     * Initiates an orderly shutdown in which previously submitted
     * tasks are executed, but no new tasks will be accepted.
     * Invocation has no additional effect if already shut down.
     *
     * <p>This method does not wait for previously submitted tasks to
     * complete execution.  Use {@link #awaitTermination awaitTermination}
     * to do that.
     *
     * @throws SecurityException {@inheritDoc}
     */
    //将线程池的状态切换为SHUTDOWN状态 该状态下会尝试中断所有的线程
    public void shutdown() {
        final ReentrantLock mainLock = this.mainLock;
        //上锁 为什么需要上锁？ 因为同一时间 只能有一个线程来将线程池的状态改为SHUTDOWN
        mainLock.lock();
        try {
            //检查是否有改变线程池状态的权限 直接无视吧 一般应该都是有权限的...
            checkShutdownAccess();
            //将线程池的状态改为SHUTDOWN
            advanceRunState(SHUTDOWN);
            //尝试中断所有线程池(如果线程正在执行任务中 ， 他是不会中断的)
            interruptIdleWorkers();
            //钩子函数 ..
            onShutdown(); // hook for ScheduledThreadPoolExecutor
        } finally {
            //解锁
            mainLock.unlock();
        }
        //尝试将线程池关闭 即从SHUTDOWN 切换到 -> TERMINATED状态
        tryTerminate();
    }


    /**
     * Common form of interruptIdleWorkers, to avoid having to
     * remember what the boolean argument means.
     */
    //尝试中断所有线程池.... 即将所有线程池的中断标志位设置为true（如果线程正在执行任务 他不会中断）
    private void interruptIdleWorkers() {
        interruptIdleWorkers(false);
    }


    //将线程池的状态设置为STOP
    //将线程池状态改变为STOP状态的时候需要返回工作队列里面还未执行的任务 这与SHUTDOWN状态的切换有区别 为啥？
    //因为切换到了STOP状态 就不会执行任何任务 包括工作队列里面还未执行的任务！
    //所以我们需要将工作队列里面还未完成的任务返回出来交给主线程来执行
    public List<Runnable> shutdownNow() {
        List<Runnable> tasks;
        final ReentrantLock mainLock = this.mainLock;
        //上锁
        mainLock.lock();
        try {
            //检查是否有改变线程池状态的权限 直接无视吧 一般应该都是有权限的...
            checkShutdownAccess();
            //将线程池的状态设置为STOP
            advanceRunState(STOP);
            //中断所有线程 即使线程正在执行任务也要中断
            interruptWorkers();
            //返回工作队列里面还未执行的任务
            tasks = drainQueue();
        } finally {
            mainLock.unlock();
        }
        tryTerminate();
        return tasks;
    }


    //获取工作队列里面还未执行的任务
    private List<Runnable> drainQueue() {
        //获取工作队列
        BlockingQueue<Runnable> q = workQueue;
        ArrayList<Runnable> taskList = new ArrayList<Runnable>();
        //* Removes all available elements from this queue and adds them
        //* to the given collection.
        //将阻塞队列里面的剩下的任务转移到taskList里面
        q.drainTo(taskList);

        //这里是防止移动元素的过程中又往阻塞队列里面添加了新的任务 健壮性判断..
        if (!q.isEmpty()) {
            for (Runnable r : q.toArray(new Runnable[0])) {
                if (q.remove(r))
                    taskList.add(r);
            }
        }
        return taskList;
    }

    //打断工作线程 即使在执行任务的工作线程也会被打断
    private void interruptWorkers() {
        final ReentrantLock mainLock = this.mainLock;
        //上锁
        mainLock.lock();
        try {

            for (MyThreadPool.Worker w : workers)
                w.interruptIfStarted();
        } finally {
            mainLock.unlock();
        }
    }

    //将线程池设置为SHUTDOWN状态触发的钩子函数 默认是空实现
    void onShutdown() {
    }


    //检查是否有改变线程池状态的权限 直接无视吧 一般应该都是有权限的...
    private void checkShutdownAccess() {
        SecurityManager security = System.getSecurityManager();
        if (security != null) {
            security.checkPermission(shutdownPerm);
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                for (MyThreadPool.Worker w : workers)
                    security.checkAccess(w.thread);
            } finally {
                mainLock.unlock();
            }
        }
    }
}

```







































































































































































































































